#!/bin/bash
# MSH v3.0 - Mini Sweet Home Unified Command
# Professional structure with bin/, lib/, config/

set -e

# Colors
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly CYAN='\033[0;36m'
readonly RED='\033[0;31m'
readonly NC='\033[0m'

# Get script directory - separate declaration and assignment for error visibility
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly SCRIPT_DIR
BIN_DIR="$SCRIPT_DIR/bin"
readonly BIN_DIR
LIB_DIR="$SCRIPT_DIR/lib"
readonly LIB_DIR
CONFIG_DIR="$SCRIPT_DIR/config"
readonly CONFIG_DIR

show_help() {
    echo -e "${CYAN}MSH v3.0 - Mini Sweet Home${NC}"
    echo -e "${CYAN}Professional Development Environment${NC}"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo
    echo "Usage: msh <command> [options]"
    echo
    echo -e "${GREEN}Installation & Setup:${NC}"
    echo "  install           - Install MSH with intelligent symlink management"
    echo "  reinstall         - Reinstall everything from scratch"
    echo "  clean             - Complete uninstall with backup restoration"
    echo
    echo -e "${GREEN}Testing & Validation:${NC}"
    echo "  test              - Run comprehensive system test"
    echo "  status            - Show detailed system status" 
    echo
    echo -e "${GREEN}Utilities:${NC}"
    echo "  aliases           - Create convenient shell aliases"
    echo
    echo -e "${GREEN}Examples:${NC}"
    echo "  msh install       - Install with automatic config backup"
    echo "  msh test          - Test your complete setup"
    echo "  msh status        - Check what's working"
    echo "  msh clean         - Completely uninstall and restore originals"
    echo "  msh aliases       - Setup convenient shortcuts"
}

# Installation state management
readonly MSH_LOG_FILE="$HOME/.msh-install.log"

# Generate timestamp
get_timestamp() {
    date +"%Y%m%d_%H%M%S"
}

# Log installation action
log_action() {
    local action="$1"
    local details="$2"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $action: $details" >> "$MSH_LOG_FILE"
}

# Backup existing config file with timestamp
backup_config() {
    local source_path="$1"
    local backup_suffix="msh-backup-$(get_timestamp)"
    
    if [[ -e "$source_path" ]]; then
        local backup_path="${source_path}.${backup_suffix}"
        if cp "$source_path" "$backup_path" 2>/dev/null; then
            echo -e "${GREEN}âœ… Backed up: $(basename "$source_path") â†’ $(basename "$backup_path")${NC}"
            log_action "BACKUP" "$source_path â†’ $backup_path"
            echo "$source_path|$backup_path" >> "${MSH_LOG_FILE}.backups"
            return 0
        else
            echo -e "${YELLOW}âš ï¸  Could not backup: $source_path${NC}"
            return 1
        fi
    fi
    return 0
}

# Create intelligent symlink
create_intelligent_symlink() {
    local target_path="$1"
    local link_path="$2"
    local config_name="$3"
    
    # If target doesn't exist, skip
    if [[ ! -f "$target_path" ]]; then
        echo -e "${YELLOW}âš ï¸  Target config not found: $target_path${NC}"
        return 1
    fi
    
    # If symlink already exists and points to correct target
    if [[ -L "$link_path" ]] && [[ "$(readlink "$link_path")" == "$target_path" ]]; then
        echo -e "${GREEN}âœ… $config_name symlink already correct${NC}"
        return 0
    fi
    
    # If symlink exists but is broken or points elsewhere, remove it
    if [[ -L "$link_path" ]]; then
        rm "$link_path" 2>/dev/null
        echo -e "${BLUE}ğŸ”— Removed old symlink: $config_name${NC}"
        log_action "REMOVE_SYMLINK" "$link_path"
    fi
    
    # If regular file/directory exists, backup it
    if [[ -e "$link_path" ]]; then
        if backup_config "$link_path"; then
            rm "$link_path" 2>/dev/null
        else
            echo -e "${RED}âŒ Failed to backup existing $config_name${NC}"
            return 1
        fi
    fi
    
    # Create new symlink
    if ln -sf "$target_path" "$link_path" 2>/dev/null; then
        echo -e "${GREEN}âœ… Created $config_name symlink${NC}"
        log_action "CREATE_SYMLINK" "$link_path â†’ $target_path"
        return 0
    else
        echo -e "${RED}âŒ Failed to create $config_name symlink${NC}"
        return 1
    fi
}

# Setup configuration symlinks intelligently
setup_config_symlinks() {
    echo -e "${BLUE}ğŸ”— Setting up intelligent configuration symlinks...${NC}"
    
    local configs=(
        "$CONFIG_DIR/shell/zsh/zshrc|$HOME/.zshrc|ZSH config"
        "$CONFIG_DIR/tmux/tmux.conf|$HOME/.tmux.conf|Tmux config" 
        "$CONFIG_DIR/git/gitconfig|$HOME/.gitconfig|Git config"
    )
    
    local success_count=0
    
    for config in "${configs[@]}"; do
        IFS='|' read -r target_path link_path config_name <<< "$config"
        if create_intelligent_symlink "$target_path" "$link_path" "$config_name"; then
            success_count=$((success_count + 1))
        fi
    done
    
    echo -e "${GREEN}âœ… Configuration symlinks: $success_count/${#configs[@]} successful${NC}"
    return 0
}

# Initialize installation log
init_install_log() {
    cat > "$MSH_LOG_FILE" << EOF
# MSH v3.0 Installation Log
# Generated: $(date)
# Installation Directory: $SCRIPT_DIR
[$(date '+%Y-%m-%d %H:%M:%S')] INSTALL_START: MSH v3.0 installation initiated
EOF
    
    # Initialize backup tracking file
    echo "# MSH Backup Tracking: source|backup" > "${MSH_LOG_FILE}.backups"
    
    log_action "LOG_INIT" "Installation logging initialized"
}

# Installation function
install_msh() {
    echo -e "${CYAN}ğŸš€ MSH v3.0 - Ultra-Fast Development Environment${NC}"
    echo -e "${CYAN}Professional Structure with Bulletproof Installation${NC}"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

    # Initialize installation logging
    init_install_log

    echo -e "${BLUE}ğŸ” Installing modern tools (bulletproof mode)...${NC}"

    # Run bulletproof installer from bin/
    if "$BIN_DIR/bulletproof-installer"; then
        echo -e "${GREEN}âœ… Tools installation complete${NC}"
        log_action "TOOLS_INSTALL" "Bulletproof installer completed successfully"
    else
        echo -e "${GREEN}âœ… Installation complete with fallbacks${NC}"
        log_action "TOOLS_INSTALL" "Bulletproof installer completed with fallbacks"
    fi

    echo
    echo -e "${BLUE}âš¡ Setting up intelligent fallbacks...${NC}"

    # Load fallbacks from lib/ (fixed path)
    # shellcheck source=lib/fallbacks.sh
    if source "$LIB_DIR/fallbacks.sh" quiet 2>/dev/null; then
        echo -e "${GREEN}âœ… Fallbacks configured${NC}"
        log_action "FALLBACKS_SETUP" "Intelligent fallbacks configured successfully"
    else
        echo -e "${YELLOW}âš ï¸  Could not load fallbacks${NC}"
        log_action "FALLBACKS_SETUP" "Warning: Could not load fallbacks"
    fi

    echo
    echo -e "${BLUE}ğŸ”§ Installing MSH system command...${NC}"
    
    # Create ~/.local/bin if it doesn't exist
    mkdir -p "$HOME/.local/bin"
    
    # Install/update msh command in system PATH
    if cp "$SCRIPT_DIR/msh" "$HOME/.local/bin/msh" 2>/dev/null; then
        chmod +x "$HOME/.local/bin/msh"
        echo -e "${GREEN}âœ… MSH command installed globally${NC}"
        log_action "MSH_INSTALL" "$HOME/.local/bin/msh installed successfully"
    else
        echo -e "${YELLOW}âš ï¸  Could not install msh globally (run: cp ~/mini-sweet-home/msh ~/.local/bin/msh)${NC}"
        log_action "MSH_INSTALL" "Warning: Could not install msh globally"
    fi
    
    echo
    # Setup intelligent configuration symlinks
    setup_config_symlinks

    echo
    echo -e "${BLUE}ğŸ›¡ï¸ Preserving your configurations...${NC}"
    echo -e "${GREEN}âœ… Prompt Î» â€º preserved${NC}"
    echo -e "${GREEN}âœ… Functions tm, gq, jp, kcef preserved${NC}"
    echo -e "${GREEN}âœ… Professional structure: bin/, lib/, config/${NC}"

    # Finalize installation log
    log_action "INSTALL_COMPLETE" "MSH v3.0 installation completed successfully"

    echo
    echo -e "${GREEN}ğŸ‰ MSH v3.0 Installation Complete!${NC}"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo -e "${BLUE}âš¡ Performance:${NC} Shell startup optimized"  
    echo -e "${BLUE}ğŸ› ï¸ Tools:${NC} Modern tools with bulletproof fallbacks"
    echo -e "${BLUE}ğŸ—ï¸ Structure:${NC} Professional bin/, lib/, config/ layout"
    echo -e "${BLUE}ğŸ›¡ï¸ Config:${NC} Your setup preserved and enhanced"
    echo -e "${BLUE}ğŸ“ Logs:${NC} Installation tracked in ~/.msh-install.log"
    echo
    echo -e "${CYAN}ğŸ’¡ Next steps:${NC}"
    echo "  1. source ~/.zshrc"
    echo "  2. msh test"
    echo "  3. msh aliases (optional convenient shortcuts)"
    echo "  4. Enjoy your professional development environment!"
    echo
    echo -e "${CYAN}ğŸ’¡ Management:${NC}"
    echo "  â€¢ Run 'msh clean' to completely uninstall MSH"
    echo "  â€¢ All changes are logged and reversible"
}

# Test function using lib/testing.sh
test_msh() {
    # Source testing library
    # shellcheck source=lib/testing.sh
    if source "$LIB_DIR/testing.sh" 2>/dev/null; then
        run_msh_test
    else
        echo -e "${RED}âŒ Testing library not found${NC}"
        exit 1
    fi
}

# Status function
status_msh() {
    echo -e "${CYAN}ğŸ“Š MSH System Status${NC}"
    echo -e "${CYAN}Professional Development Environment${NC}"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    
    # Check structure
    echo -e "${BLUE}ğŸ“ Project Structure:${NC}"
    echo "  bin/    $(ls -1 "$BIN_DIR" 2>/dev/null | wc -l) executables"
    echo "  lib/    $(ls -1 "$LIB_DIR" 2>/dev/null | wc -l) libraries"
    echo "  config/ $(find "$CONFIG_DIR" -name "*.zsh" -o -name "*.lua" 2>/dev/null | wc -l) configuration files"
    echo
    
    # Check tools
    echo -e "${BLUE}ğŸ› ï¸ Modern Tools:${NC}"
    local tools=("fzy" "rg" "fd" "bat" "eza" "dust" "zoxide" "cmake")
    local available=0
    
    for tool in "${tools[@]}"; do
        if command -v "$tool" >/dev/null 2>&1; then
            echo -e "  ${GREEN}âœ… $tool${NC}"
            available=$((available + 1))
        else
            echo -e "  ${YELLOW}â—‹ $tool (fallback active)${NC}"
        fi
    done
    echo "  Available: $available/${#tools[@]} tools"
    echo
    
    # Check functions
    if source "$CONFIG_DIR/shell/zsh/functions.zsh" 2>/dev/null && declare -f tm >/dev/null; then
        echo -e "${GREEN}âœ… Personal functions loaded (tm, gq, jp, kcef)${NC}"
    else
        echo -e "${YELLOW}âš ï¸  Personal functions not loaded${NC}"
    fi
    
    # Check fallbacks
    # shellcheck source=lib/fallbacks.sh
    if source "$LIB_DIR/fallbacks.sh" quiet 2>/dev/null; then
        echo -e "${GREEN}âœ… Intelligent fallbacks active${NC}"
        echo "  Fuzzy: $MSH_FUZZY_FINDER | List: $MSH_LIST_TOOL | Grep: $MSH_GREP_TOOL"
    else
        echo -e "${YELLOW}âš ï¸  Fallbacks not loaded${NC}"
    fi
}

# Create aliases using bin/create-aliases
create_aliases() {
    echo -e "${BLUE}ğŸ”— Creating convenient aliases...${NC}"
    if "$BIN_DIR/create-aliases"; then
        echo -e "${GREEN}âœ… Aliases created successfully${NC}"
    else
        echo -e "${RED}âŒ Failed to create aliases${NC}"
        exit 1
    fi
}

# Restore backed up config files
restore_config_backups() {
    local backups_file="${MSH_LOG_FILE}.backups"
    local restored_count=0
    
    if [[ ! -f "$backups_file" ]]; then
        echo -e "${YELLOW}âš ï¸  No backup file found${NC}"
        return 0
    fi
    
    echo -e "${BLUE}ğŸ”„ Restoring backed up configurations...${NC}"
    
    # Read backup mappings (skip comment lines)
    while IFS='|' read -r source_path backup_path; do
        [[ "$source_path" =~ ^# ]] && continue  # Skip comments
        [[ -z "$source_path" || -z "$backup_path" ]] && continue  # Skip empty lines
        
        if [[ -f "$backup_path" ]]; then
            # Remove current symlink/file
            if [[ -e "$source_path" ]]; then
                rm "$source_path" 2>/dev/null
            fi
            
            # Restore backup
            if mv "$backup_path" "$source_path" 2>/dev/null; then
                echo -e "${GREEN}âœ… Restored: $(basename "$source_path")${NC}"
                restored_count=$((restored_count + 1))
            else
                echo -e "${YELLOW}âš ï¸  Could not restore: $source_path${NC}"
            fi
        else
            echo -e "${YELLOW}âš ï¸  Backup not found: $backup_path${NC}"
        fi
    done < "$backups_file"
    
    echo -e "${GREEN}âœ… Restored $restored_count configuration files${NC}"
    return 0
}

# Remove MSH symlinks
remove_msh_symlinks() {
    echo -e "${BLUE}ğŸ”— Removing MSH configuration symlinks...${NC}"
    
    local configs=(
        "$HOME/.zshrc|ZSH config"
        "$HOME/.tmux.conf|Tmux config" 
        "$HOME/.gitconfig|Git config"
    )
    
    local removed_count=0
    
    for config in "${configs[@]}"; do
        IFS='|' read -r link_path config_name <<< "$config"
        
        if [[ -L "$link_path" ]]; then
            # Check if it's an MSH symlink (points to mini-sweet-home)
            if [[ "$(readlink "$link_path")" =~ mini-sweet-home ]]; then
                if rm "$link_path" 2>/dev/null; then
                    echo -e "${GREEN}âœ… Removed $config_name symlink${NC}"
                    removed_count=$((removed_count + 1))
                else
                    echo -e "${YELLOW}âš ï¸  Could not remove $config_name symlink${NC}"
                fi
            else
                echo -e "${BLUE}â„¹ï¸  $config_name symlink not managed by MSH${NC}"
            fi
        elif [[ -e "$link_path" ]]; then
            echo -e "${BLUE}â„¹ï¸  $config_name is not a symlink, skipping${NC}"
        else
            echo -e "${BLUE}â„¹ï¸  No $config_name found${NC}"
        fi
    done
    
    echo -e "${GREEN}âœ… Removed $removed_count MSH symlinks${NC}"
    return 0
}

# Clean uninstall function
clean_msh() {
    echo -e "${CYAN}ğŸ§¹ MSH v3.0 - Complete Clean Uninstall${NC}"
    echo -e "${CYAN}Removing MSH and Restoring Original System${NC}"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    
    # Check if MSH is installed
    if [[ ! -f "$MSH_LOG_FILE" ]]; then
        echo -e "${YELLOW}âš ï¸  MSH installation log not found${NC}"
        echo -e "${YELLOW}    MSH may not be installed or was manually removed${NC}"
        echo -e "${BLUE}â„¹ï¸  Will attempt to clean up any remaining MSH components${NC}"
    else
        echo -e "${BLUE}ğŸ“‹ Found MSH installation log${NC}"
        echo -e "${BLUE}    Installed: $(grep 'INSTALL_START' "$MSH_LOG_FILE" | cut -d']' -f1 | tr -d '[')${NC}"
    fi
    
    echo
    
    # Remove MSH symlinks
    remove_msh_symlinks
    
    echo
    
    # Restore backed up configs
    restore_config_backups
    
    echo
    echo -e "${BLUE}ğŸ—‘ï¸  Removing MSH system components...${NC}"
    
    # Remove MSH from system PATH
    if [[ -f "$HOME/.local/bin/msh" ]]; then
        if rm "$HOME/.local/bin/msh" 2>/dev/null; then
            echo -e "${GREEN}âœ… Removed MSH command from system PATH${NC}"
        else
            echo -e "${YELLOW}âš ï¸  Could not remove MSH command${NC}"
        fi
    else
        echo -e "${BLUE}â„¹ï¸  MSH command not found in system PATH${NC}"
    fi
    
    # Clean up installation logs
    if [[ -f "$MSH_LOG_FILE" ]]; then
        if rm "$MSH_LOG_FILE" 2>/dev/null; then
            echo -e "${GREEN}âœ… Removed installation log${NC}"
        else
            echo -e "${YELLOW}âš ï¸  Could not remove installation log${NC}"
        fi
    fi
    
    if [[ -f "${MSH_LOG_FILE}.backups" ]]; then
        if rm "${MSH_LOG_FILE}.backups" 2>/dev/null; then
            echo -e "${GREEN}âœ… Removed backup tracking file${NC}"
        else
            echo -e "${YELLOW}âš ï¸  Could not remove backup tracking file${NC}"
        fi
    fi
    
    echo
    echo -e "${GREEN}ğŸ‰ MSH Clean Uninstall Complete!${NC}"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo -e "${BLUE}âœ… System State:${NC} Restored to pre-MSH configuration"
    echo -e "${BLUE}âœ… Symlinks:${NC} MSH symlinks removed"
    echo -e "${BLUE}âœ… Configs:${NC} Original configurations restored"
    echo -e "${BLUE}âœ… Cleanup:${NC} Installation logs removed"
    echo
    echo -e "${CYAN}ğŸ’¡ Note:${NC}"
    echo "  â€¢ Your mini-sweet-home directory is preserved"
    echo "  â€¢ Installed tools (fzy, rg, bat, etc.) remain available"
    echo "  â€¢ You can reinstall MSH anytime with './msh install'"
    echo
    echo -e "${CYAN}ğŸ’¡ Next steps:${NC}"
    echo "  1. source ~/.zshrc (to load restored configuration)"
    echo "  2. Your system is back to its original state"
}

# Main command dispatcher
case "${1:-help}" in
    install|i)
        install_msh
        ;;
    reinstall)
        echo -e "${YELLOW}ğŸ”„ Reinstalling MSH...${NC}"
        install_msh
        ;;
    clean|uninstall)
        # Confirm before cleaning
        echo -e "${YELLOW}âš ï¸  This will completely remove MSH and restore your original configurations.${NC}"
        echo -n "Are you sure? [y/N]: "
        read -r response
        if [[ "$response" =~ ^[Yy]$ ]]; then
            clean_msh
        else
            echo -e "${BLUE}â„¹ï¸  Clean operation cancelled${NC}"
        fi
        ;;
    test|t)
        test_msh
        ;;
    status|s)
        status_msh
        ;;
    aliases|a)
        create_aliases
        ;;
    help|--help|-h|"")
        show_help
        ;;
    *)
        echo -e "${RED}Unknown command: $1${NC}"
        echo "Run 'msh help' for usage information"
        exit 1
        ;;
esac