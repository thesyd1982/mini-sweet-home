#!/bin/bash

# ================================================
# ğŸ  MINI SWEET HOME - BENCHMARK SCRIPT v2.1
# ================================================
# Benchmark intelligent avec activation/dÃ©sactivation d'outils

set -uo pipefail  # Retirer -e

readonly SCRIPT_VERSION="2.1"
readonly BENCHMARK_DIR="/tmp/msh-benchmark-$$"
readonly TEST_FILES_COUNT=500
readonly RUNS=10
readonly CONFIG_FILE="$HOME/.config/msh/tools.conf"

# Couleurs
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly CYAN='\033[0;36m'
readonly BOLD='\033[1m'
readonly RESET='\033[0m'

# Variables globales pour rÃ©sultats
declare -A BENCHMARK_RESULTS=()
declare -A TOOL_STATUS=()

log_info() { echo -e "${BLUE}[INFO]${RESET} $1"; }
log_success() { echo -e "${GREEN}[âœ“]${RESET} $1"; }
log_warning() { echo -e "${YELLOW}[âš ]${RESET} $1"; }
log_error() { echo -e "${RED}[âœ—]${RESET} $1"; }
log_header() { echo -e "${CYAN}${BOLD}$1${RESET}"; }

command_exists() { command -v "$1" >/dev/null 2>&1; }

load_config() {
    mkdir -p "$(dirname "$CONFIG_FILE")"
    
    # Initialiser les arrays
    declare -gA TOOL_STATUS=()
    declare -gA BENCHMARK_RESULTS=()
    
    if [[ -f "$CONFIG_FILE" ]]; then
        source "$CONFIG_FILE"
    else
        # Valeurs par dÃ©faut
        TOOL_STATUS[eza]="enabled"
        TOOL_STATUS[fd]="enabled"
        TOOL_STATUS[rg]="enabled"
        TOOL_STATUS[bat]="enabled"
        TOOL_STATUS[dust]="enabled"
        TOOL_STATUS[starship]="enabled"
    fi
}

save_config() {
    cat > "$CONFIG_FILE" << EOF
# Configuration des outils MSH
TOOL_STATUS[eza]="${TOOL_STATUS[eza]:-enabled}"
TOOL_STATUS[fd]="${TOOL_STATUS[fd]:-enabled}"
TOOL_STATUS[rg]="${TOOL_STATUS[rg]:-enabled}"
TOOL_STATUS[bat]="${TOOL_STATUS[bat]:-enabled}"
TOOL_STATUS[dust]="${TOOL_STATUS[dust]:-enabled}"
TOOL_STATUS[starship]="${TOOL_STATUS[starship]:-enabled}"
EOF
    log_success "Configuration sauvegardÃ©e"
}

check_hyperfine() {
    if command_exists hyperfine; then
        echo "using_hyperfine"
    else
        echo "basic_timing"
    fi
}

create_test_environment() {
    log_info "CrÃ©ation environnement test..."
    mkdir -p "$BENCHMARK_DIR"
    cd "$BENCHMARK_DIR"
    
    for i in $(seq 1 $((TEST_FILES_COUNT / 4))); do
        echo "Test file $i with content for searching" > "text_$i.txt"
        echo "#!/bin/bash\necho 'Script $i'" > "script_$i.sh"
        echo "data_$i,value_$i" > "data_$i.csv"
        echo "$(date): Log entry $i" > "app_$i.log"
    done
    
    mkdir -p deep/nested/structure
    dd if=/dev/urandom of="large_file.bin" bs=1M count=5 2>/dev/null
    log_success "Environnement crÃ©Ã©"
}

format_time() {
    local time_ms="$1"
    if (( time_ms >= 1000 )); then
        printf "%.2fs" "$(echo "scale=2; $time_ms / 1000" | bc -l 2>/dev/null || echo "?s")"
    else
        printf "%dms" "$time_ms"
    fi
}

benchmark_with_basic_timing() {
    local test_name="$1"
    shift
    local commands=("$@")
    
    log_header "â±ï¸ $test_name"
    
    for cmd in "${commands[@]}"; do
        local total_time=0
        local successful_runs=0
        
        for run in $(seq 1 $RUNS); do
            local start_time=$(date +%s%3N)
            if eval "$cmd" >/dev/null 2>&1; then
                local end_time=$(date +%s%3N)
                local run_time=$((end_time - start_time))
                total_time=$((total_time + run_time))
                successful_runs=$((successful_runs + 1))
            fi
        done
        
        if [[ $successful_runs -gt 0 ]]; then
            local avg_time=$((total_time / successful_runs))
            local tool_name=$(echo "$cmd" | awk '{print $1}')
            BENCHMARK_RESULTS["$tool_name"]=$avg_time
            printf "  %-20s %s\n" "$tool_name" "$(format_time $avg_time)"
        else
            printf "  %-20s FAILED\n" "$(echo "$cmd" | awk '{print $1}')"
        fi
    done
    echo
}

benchmark_with_hyperfine() {
    local test_name="$1"
    shift
    local commands=("$@")
    
    log_header "ğŸƒ $test_name"
    
    # Sauvegarder les temps pour chaque commande
    for cmd in "${commands[@]}"; do
        local tool_name=$(echo "$cmd" | awk '{print $1}')
        local temp_file="/tmp/hyperfine_$tool_name.json"
        
        if hyperfine --runs $RUNS --warmup 2 --export-json "$temp_file" "$cmd" 2>/dev/null; then
            # Extraire le temps moyen en ms depuis le JSON
            local mean_time=$(python3 -c "import json; data=json.load(open('$temp_file')); print(int(data['results'][0]['mean']*1000))" 2>/dev/null || echo "0")
            BENCHMARK_RESULTS["$tool_name"]=$mean_time
            rm -f "$temp_file"
        else
            log_warning "Ã‰chec benchmark $tool_name avec hyperfine"
            # Fallback timing basique pour cet outil
            local start_time=$(date +%s%3N)
            if eval "$cmd" >/dev/null 2>&1; then
                local end_time=$(date +%s%3N)
                BENCHMARK_RESULTS["$tool_name"]=$((end_time - start_time))
            fi
        fi
    done
    
    # Afficher hyperfine pour l'utilisateur
    hyperfine --runs $RUNS --warmup 2 "${commands[@]}" 2>/dev/null || {
        log_warning "Hyperfine Ã©chouÃ©, fallback timing basique"
        benchmark_with_basic_timing "$test_name" "${commands[@]}"
    }
}

run_benchmarks() {
    local method="$1"
    create_test_environment
    
    # Tests listage
    local list_commands=()
    command_exists ls && list_commands+=("ls -la")
    command_exists eza && list_commands+=("eza -la")
    [[ ${#list_commands[@]} -gt 0 ]] && benchmark_with_${method#using_} "ğŸ“ Listage fichiers" "${list_commands[@]}"
    
    # Tests recherche fichiers
    local find_commands=()
    command_exists find && find_commands+=("find . -name '*.txt' -type f")
    command_exists fd && find_commands+=("fd '\\.txt$'")
    [[ ${#find_commands[@]} -gt 0 ]] && benchmark_with_${method#using_} "ğŸ” Recherche fichiers" "${find_commands[@]}"
    
    # Tests recherche texte
    local grep_commands=()
    command_exists grep && grep_commands+=("grep -r 'test' .")
    command_exists rg && grep_commands+=("rg 'test'")
    [[ ${#grep_commands[@]} -gt 0 ]] && benchmark_with_${method#using_} "ğŸ“ Recherche texte" "${grep_commands[@]}"
    
    # Tests visualisation
    local view_commands=()
    command_exists cat && view_commands+=("cat script_1.sh")
    command_exists bat && view_commands+=("bat script_1.sh")
    [[ ${#view_commands[@]} -gt 0 ]] && benchmark_with_${method#using_} "ğŸ‘€ Visualisation" "${view_commands[@]}"
    
    # Tests analyse disque
    local disk_commands=()
    command_exists du && disk_commands+=("du -sh .")
    command_exists dust && disk_commands+=("dust -d 1 .")
    [[ ${#disk_commands[@]} -gt 0 ]] && benchmark_with_${method#using_} "ğŸ’¾ Analyse disque" "${disk_commands[@]}"
    
    cleanup
}

show_results() {
    log_header "ğŸ“Š RÃ©sultats dÃ©taillÃ©s du benchmark"
    echo
    
    # VÃ©rifier si des rÃ©sultats existent
    if [[ ${#BENCHMARK_RESULTS[@]} -eq 0 ]]; then
        log_warning "Aucun rÃ©sultat de benchmark disponible"
        return 0
    fi
    
    # Afficher tous les rÃ©sultats
    echo "â±ï¸ Temps d'exÃ©cution :"
    for tool in $(printf '%s\n' "${!BENCHMARK_RESULTS[@]}" | sort); do
        printf "  %-15s %s\n" "$tool:" "$(format_time ${BENCHMARK_RESULTS[$tool]})"
    done
    echo
    
    # Comparaisons et recommandations
    log_header "ğŸ¯ Comparaisons et optimisations"
    echo
    
    [[ -n "${BENCHMARK_RESULTS[ls]:-}" && -n "${BENCHMARK_RESULTS[eza]:-}" ]] && {
        local diff=$(( BENCHMARK_RESULTS[ls] - BENCHMARK_RESULTS[eza] ))
        if [[ $diff -gt 50 ]]; then
            echo "âœ… eza est $(format_time $diff) plus rapide que ls - RECOMMANDÃ‰"
            echo "   ğŸ’¡ Optimisation: CrÃ©er alias 'ls=eza -la --icons'"
        elif [[ $diff -lt -50 ]]; then
            echo "âš ï¸  ls est $(format_time ${diff#-}) plus rapide que eza"
            echo "   ğŸ’¡ Conseil: Garder ls pour scripts, eza pour usage interactif"
        else
            echo "âš¡ ls et eza ont des performances similaires"
        fi
        echo
    } || {
        # Si eza pas installÃ©, suggÃ©rer installation
        [[ -n "${BENCHMARK_RESULTS[ls]:-}" ]] && {
            echo "ğŸ’¡ Suggestion: Installer eza pour un listage plus moderne"
            echo "   cargo install eza"
            echo
        }
    }
    
    [[ -n "${BENCHMARK_RESULTS[find]:-}" && -n "${BENCHMARK_RESULTS[fd]:-}" ]] && {
        local diff=$(( BENCHMARK_RESULTS[find] - BENCHMARK_RESULTS[fd] ))
        if [[ $diff -gt 100 ]]; then
            echo "âœ… fd est $(format_time $diff) plus rapide que find - RECOMMANDÃ‰"
            echo "   ğŸ’¡ Optimisation: Remplacer 'find . -name' par 'fd'"
        else
            echo "âš¡ find et fd ont des performances similaires"
        fi
        echo
    }
    
    [[ -n "${BENCHMARK_RESULTS[grep]:-}" && -n "${BENCHMARK_RESULTS[rg]:-}" ]] && {
        local diff=$(( BENCHMARK_RESULTS[grep] - BENCHMARK_RESULTS[rg] ))
        if [[ $diff -gt 200 ]]; then
            echo "âœ… ripgrep est $(format_time $diff) plus rapide que grep - RECOMMANDÃ‰"
            echo "   ğŸ’¡ Optimisation: Alias 'grep=rg' pour recherches courantes"
        else
            echo "âš¡ grep et ripgrep ont des performances similaires"
        fi
        echo
    }
    
    [[ -n "${BENCHMARK_RESULTS[cat]:-}" && -n "${BENCHMARK_RESULTS[bat]:-}" ]] && {
        local diff=$(( BENCHMARK_RESULTS[bat] - BENCHMARK_RESULTS[cat] ))
        if [[ $diff -lt 100 ]]; then
            echo "âœ… bat ajoute syntax highlighting avec overhead minimal"
            echo "   ğŸ’¡ Optimisation: Alias 'cat=bat --style=plain' pour fichiers code"
        else
            echo "âš ï¸  bat est $(format_time $diff) plus lent que cat"
            echo "   ğŸ’¡ Conseil: Garder cat pour scripts, bat pour dÃ©veloppement"
        fi
        echo
    }
    
    [[ -n "${BENCHMARK_RESULTS[du]:-}" && -n "${BENCHMARK_RESULTS[dust]:-}" ]] && {
        local diff=$(( BENCHMARK_RESULTS[du] - BENCHMARK_RESULTS[dust] ))
        if [[ $diff -gt 50 ]]; then
            echo "âœ… dust est $(format_time $diff) plus rapide que du - RECOMMANDÃ‰"
            echo "   ğŸ’¡ Optimisation: Alias 'du=dust' pour analyse disque"
        else
            echo "âš¡ du et dust ont des performances similaires"
        fi
        echo
    }
    
    # Score global - seulement outils installÃ©s
    local modern_tools=0
    local total_comparisons=0
    
    [[ -n "${BENCHMARK_RESULTS[eza]:-}" ]] && ((modern_tools++))
    [[ -n "${BENCHMARK_RESULTS[fd]:-}" ]] && ((modern_tools++))
    [[ -n "${BENCHMARK_RESULTS[rg]:-}" ]] && ((modern_tools++))
    [[ -n "${BENCHMARK_RESULTS[bat]:-}" ]] && ((modern_tools++))
    [[ -n "${BENCHMARK_RESULTS[dust]:-}" ]] && ((modern_tools++))
    total_comparisons=5  # Total possible
    
    if [[ $total_comparisons -gt 0 ]]; then
        local score=$(( (modern_tools * 100) / total_comparisons ))
        log_header "ğŸ† Score d'optimisation: ${score}% (${modern_tools}/5 outils modernes)"
        
        if [[ $score -ge 80 ]]; then
            echo "ğŸ‰ Excellent ! Votre environnement est bien optimisÃ©"
        elif [[ $score -ge 60 ]]; then
            echo "ğŸ‘ Bon niveau d'optimisation, quelques amÃ©liorations possibles"
        else
            echo "ğŸ”§ Potentiel d'amÃ©lioration important - installez plus d'outils modernes"
            echo "   ğŸ’¡ make modern  # Pour installer tous les outils"
        fi
        echo
    fi
}

toggle_tool() {
    local tool="$1"
    if [[ "${TOOL_STATUS[$tool]}" == "enabled" ]]; then
        TOOL_STATUS[$tool]="disabled"
        log_warning "$tool dÃ©sactivÃ©"
    else
        TOOL_STATUS[$tool]="enabled"
        log_success "$tool activÃ©"
    fi
}

tool_management_menu() {
    while true; do
        clear
        log_header "ğŸ› ï¸ Gestion des outils"
        echo
        
        local tools=("eza" "fd" "rg" "bat" "dust" "starship")
        local i=1
        for tool in "${tools[@]}"; do
            local status_icon="âŒ"
            local status_text="dÃ©sactivÃ©"
            if [[ "${TOOL_STATUS[$tool]:-disabled}" == "enabled" ]]; then
                status_icon="âœ…"
                status_text="activÃ©"
            fi
            printf "  %d) %-10s [%s] %s\n" $i "$tool" "$status_icon" "$status_text"
            ((i++))
        done
        
        echo
        echo "  7) ğŸ’¾ Sauvegarder configuration"
        echo "  8) ğŸ”„ Recharger configuration"
        echo "  0) â†©ï¸  Retour"
        echo
        
        read -p "Choix [0-8]: " choice
        
        case $choice in
            1) toggle_tool "eza" ;;
            2) toggle_tool "fd" ;;
            3) toggle_tool "rg" ;;
            4) toggle_tool "bat" ;;
            5) toggle_tool "dust" ;;
            6) toggle_tool "starship" ;;
            7) save_config; read -p "Appuyez sur EntrÃ©e..." ;;
            8) load_config; log_success "Configuration rechargÃ©e" ;;
            0) break ;;
            *) log_error "Choix invalide" ;;
        esac
        
        [[ $choice =~ ^[1-6]$ ]] && sleep 1
    done
}

cleanup() {
    cd /
    rm -rf "$BENCHMARK_DIR" 2>/dev/null || true
}

main() {
    clear
    log_header "ğŸ  Mini Sweet Home - Benchmark v$SCRIPT_VERSION"
    echo
    
    load_config
    local method=$(check_hyperfine)
    
    echo "ğŸš€ Lancement du benchmark..."
    echo
    run_benchmarks "$method"
    
    show_results
    
    echo "ğŸ› ï¸ Voulez-vous gÃ©rer l'activation des outils ?"
    read -p "Ouvrir le menu de gestion ? [Y/n]: " -r
    if [[ ! $REPLY =~ ^[Nn]$ ]]; then
        tool_management_menu
    fi
    
    log_success "Benchmark terminÃ© !"
    exit 0
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
